---
description: Follow best practices for testing Nuxt applications using Vitest and Vue Test Utils
globs: **/*.{spec,test}.{ts,js}
alwaysApply: false
---

# Nuxt Testing

## Context
Rules for implementing tests in Nuxt applications.
- Use Vitest for unit and integration testing
- Use Vue Test Utils for component testing
- Implement proper test organization
- Handle async operations properly

## Requirements
- Use proper test organization with describe/it blocks
- Implement proper component mounting
- Use data-test attributes for selectors
- Handle async operations properly
- Implement proper mocking
- Use proper assertions
- Clean up after tests
- Test component contracts
- Handle edge cases
- Write meaningful test descriptions

## Examples
<example>
import { createTestingPinia } from '@pinia/testing'
import { mount } from '@vue/test-utils'
import { describe, expect, it, vi } from 'vitest'
import UserProfile from '~/components/UserProfile.vue'
import { useUserStore } from '~/stores/user'

describe('userProfile', () => {
  // Setup mock data
  const mockUser = {
    id: '1',
    name: 'John Doe',
    email: 'john@example.com',
    preferences: {
      theme: 'light',
      notifications: true,
    },
  }

  // Helper to create wrapper with options
  function createWrapper(options = {}) {
    return mount(UserProfile, {
      global: {
        plugins: [
          createTestingPinia({
            createSpy: vi.fn,
            initialState: {
              user: { user: mockUser },
            },
          }),
        ],
        stubs: {
          NuxtLink: true,
        },
      },
      ...options,
    })
  }

  it('renders user information correctly', () => {
    const wrapper = createWrapper()

    expect(wrapper.find('[data-test="user-name"]').text()).toBe(mockUser.name)
    expect(wrapper.find('[data-test="user-email"]').text()).toBe(mockUser.email)
  })

  it('updates user preferences', async () => {
    const wrapper = createWrapper()
    const store = useUserStore()

    // Trigger preference change
    await wrapper.find('[data-test="theme-toggle"]').trigger('click')

    expect(store.updatePreferences).toHaveBeenCalledWith({
      theme: 'dark',
    })
  })

  it('handles loading state', () => {
    const wrapper = createWrapper({
      global: {
        plugins: [
          createTestingPinia({
            createSpy: vi.fn,
            initialState: {
              user: { loading: true },
            },
          }),
        ],
      },
    })

    expect(wrapper.find('[data-test="loading"]').exists()).toBe(true)
    expect(wrapper.find('[data-test="user-info"]').exists()).toBe(false)
  })

  it('handles error state', () => {
    const error = new Error('Failed to load user')
    const wrapper = createWrapper({
      global: {
        plugins: [
          createTestingPinia({
            createSpy: vi.fn,
            initialState: {
              user: { error },
            },
          }),
        ],
      },
    })

    expect(wrapper.find('[data-test="error"]').text()).toContain(error.message)
  })
})

</example>

<example>
import { createPinia, setActivePinia } from 'pinia'
import { beforeEach, describe, expect, it, vi } from 'vitest'
import { useCart } from '~/composables/useCart'

describe('useCart', () => {
  beforeEach(() => {
    // Create a fresh pinia instance
    setActivePinia(createPinia())

    // Mock fetch
    vi.mock('#app', () => ({
      useFetch: vi.fn(() => ({
        data: ref(null),
        error: ref(null),
        pending: ref(false),
      })),
    }))
  })

  it('initializes with empty cart', () => {
    const { items, totalItems, totalPrice } = useCart()

    expect(items.value).toHaveLength(0)
    expect(totalItems.value).toBe(0)
    expect(totalPrice.value).toBe(0)
  })

  it('adds item to cart', async () => {
    const { addItem, items, totalItems } = useCart()
    const mockItem = {
      id: '1',
      name: 'Test Product',
      price: 9.99,
    }

    await addItem(mockItem)

    expect(items.value).toHaveLength(1)
    expect(items.value[0]).toMatchObject({
      ...mockItem,
      quantity: 1,
    })
    expect(totalItems.value).toBe(1)
  })

  it('updates item quantity', async () => {
    const { addItem, updateQuantity, items } = useCart()
    const mockItem = {
      id: '1',
      name: 'Test Product',
      price: 9.99,
    }

    await addItem(mockItem)
    await updateQuantity('1', 3)

    expect(items.value[0].quantity).toBe(3)
  })

  it('removes item from cart', async () => {
    const { addItem, removeItem, items } = useCart()
    const mockItem = {
      id: '1',
      name: 'Test Product',
      price: 9.99,
    }

    await addItem(mockItem)
    await removeItem('1')

    expect(items.value).toHaveLength(0)
  })

  it('calculates total price correctly', async () => {
    const { addItem, totalPrice } = useCart()
    const mockItems = [
      { id: '1', name: 'Product 1', price: 10.00 },
      { id: '2', name: 'Product 2', price: 20.00 },
    ]

    await Promise.all(mockItems.map(item => addItem(item)))

    expect(totalPrice.value).toBe(30.00)
  })

  it('handles errors when adding items', async () => {
    vi.mock('#app', () => ({
      useFetch: vi.fn(() => {
        throw new Error('Network error')
      }),
    }))

    const { addItem } = useCart()
    const mockItem = {
      id: '1',
      name: 'Test Product',
      price: 9.99,
    }

    await expect(addItem(mockItem)).rejects.toThrow('Network error')
  })
})

</example>

<example type="invalid">
// ❌ Wrong: No proper test organization
import { mount } from '@vue/test-utils'
import MyComponent from './MyComponent.vue'

// ❌ Wrong: No describe blocks
it('it works', () => {
  // ❌ Wrong: No proper component mounting
  const wrapper = mount(MyComponent)
  expect(wrapper.text()).toBe('something')
})

// ❌ Wrong: Testing implementation details
it('internal method works', () => {
  const wrapper = mount(MyComponent)
  // ❌ Wrong: Accessing private methods
  expect(wrapper.vm._calculateTotal()).toBe(100)
})

// ❌ Wrong: No error handling
it('api call works', async () => {
  const wrapper = mount(MyComponent)
  // ❌ Wrong: No proper async handling
  await wrapper.vm.fetchData()
  expect(wrapper.text()).toBe('data')
})

// ❌ Wrong: Testing multiple things
it('component functionality', () => {
  const wrapper = mount(MyComponent)

  // ❌ Wrong: Multiple assertions without context
  expect(wrapper.find('button').exists()).toBe(true)
  expect(wrapper.text()).toContain('hello')
  expect(wrapper.vm.data).toBeDefined()
  expect(wrapper.emitted().click).toBeTruthy()
})

// ❌ Wrong: No cleanup
it('state changes', () => {
  // ❌ Wrong: Modifying global state without cleanup
  window.localStorage.setItem('test', 'value')
  const wrapper = mount(MyComponent)
  expect(wrapper.vm.value).toBe('value')
})

// ❌ Wrong: Hardcoded timeouts
it('async operation', async () => {
  const wrapper = mount(MyComponent)
  wrapper.vm.doSomething()
  // ❌ Wrong: Using setTimeout in tests
  await new Promise(resolve => setTimeout(resolve, 1000))
  expect(wrapper.text()).toBe('done')
})

</example>


## Critical Rules
- ALWAYS use proper test organization
- Handle async operations properly
- Implement proper mocking
- Clean up after tests
- Use meaningful assertions
- Test component contracts
