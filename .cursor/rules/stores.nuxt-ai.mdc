---
description: Follow best practices for state management using Pinia in Nuxt applications
globs: **/stores/**/*.{ts,js}
alwaysApply: false
---

# Nuxt Store Management

## Context
Rules for implementing stores in Nuxt applications.
- Use Pinia for state management
- Implement proper TypeScript types
- Handle async operations properly
- Maintain proper store structure

## Requirements
- Use Pinia for state management
- Implement proper TypeScript types
- Use proper store structure (state, getters, actions)
- Handle async operations properly
- Implement proper error handling
- Use proper naming conventions
- Avoid direct state mutations
- Implement proper store modules
- Use composables when appropriate
- Handle SSR properly

## Examples
<example>
import { defineStore } from 'pinia'

interface CartItem {
  id: string
  name: string
  price: number
  quantity: number
}

interface CartState {
  items: CartItem[]
  loading: boolean
  error: Error | null
}

export const useCartStore = defineStore('cart', {
  state: (): CartState => ({
    items: [],
    loading: false,
    error: null,
  }),

  getters: {
    totalItems: state => state.items.reduce((sum, item) => sum + item.quantity, 0),
    totalPrice: state => state.items.reduce((sum, item) => sum + (item.price * item.quantity), 0),
    isEmpty: state => state.items.length === 0,
  },

  actions: {
    async addItem(item: Omit<CartItem, 'quantity'>) {
      this.loading = true

      try {
        // Check if item already exists
        const existingItem = this.items.find(i => i.id === item.id)

        if (existingItem) {
          await this.updateQuantity(item.id, existingItem.quantity + 1)
        }
        else {
          // Add new item
          const { data } = await useFetch('/api/cart/add', {
            method: 'POST',
            body: { ...item, quantity: 1 },
          })

          this.items.push({ ...item, quantity: 1 })
        }
      }
      catch (err) {
        this.error = err as Error
        throw createError({
          statusCode: 400,
          message: 'Failed to add item to cart',
        })
      }
      finally {
        this.loading = false
      }
    },

    async updateQuantity(itemId: string, quantity: number) {
      if (quantity < 0)
        return

      try {
        await useFetch(`/api/cart/${itemId}`, {
          method: 'PATCH',
          body: { quantity },
        })

        const item = this.items.find(i => i.id === itemId)
        if (item) {
          item.quantity = quantity
        }
      }
      catch (err) {
        throw createError({
          statusCode: 400,
          message: 'Failed to update quantity',
        })
      }
    },

    async removeItem(itemId: string) {
      try {
        await useFetch(`/api/cart/${itemId}`, {
          method: 'DELETE',
        })

        this.items = this.items.filter(item => item.id !== itemId)
      }
      catch (err) {
        throw createError({
          statusCode: 400,
          message: 'Failed to remove item',
        })
      }
    },

    clearCart() {
      this.items = []
      this.error = null
    },
  },
})

</example>

<example>
import { defineStore } from 'pinia'

interface User {
  id: string
  email: string
  name: string
  preferences: UserPreferences
}

interface UserPreferences {
  theme: 'light' | 'dark'
  notifications: boolean
}

export const useUserStore = defineStore('user', {
  state: () => ({
    user: null as User | null,
    loading: false,
    error: null as Error | null,
  }),

  getters: {
    isAuthenticated: state => !!state.user,
    userPreferences: state => state.user?.preferences,
    userName: state => state.user?.name,
  },

  actions: {
    async fetchUser() {
      this.loading = true
      this.error = null

      try {
        const { data } = await useFetch<User>('/api/user')
        this.user = data.value
      }
      catch (err) {
        this.error = err as Error
        throw err
      }
      finally {
        this.loading = false
      }
    },

    async updatePreferences(preferences: Partial<UserPreferences>) {
      if (!this.user)
        return

      try {
        const { data } = await useFetch<User>('/api/user/preferences', {
          method: 'PATCH',
          body: preferences,
        })

        this.user = {
          ...this.user,
          preferences: {
            ...this.user.preferences,
            ...preferences,
          },
        }
      }
      catch (err) {
        throw createError({
          statusCode: 400,
          message: 'Failed to update preferences',
        })
      }
    },

    clearUser() {
      this.user = null
      this.error = null
    },
  },
})

</example>

<example type="invalid">
// ❌ Wrong: Not using Pinia or proper store structure
const globalStore = {
  // ❌ Wrong: Using mutable global state
  state: {
    user: null,
    cart: [],
    settings: {},
  },

  // ❌ Wrong: Not using proper mutations/actions
  setUser(user) {
    this.state.user = user
  },

  // ❌ Wrong: Direct state mutation
  addToCart(item) {
    this.state.cart.push(item)
  },

  // ❌ Wrong: No error handling
  async fetchData() {
    const response = await fetch('/api/data')
    const data = await response.json()
    this.state = { ...this.state, ...data }
  },
}

// ❌ Wrong: Exposing store globally
if (process.client) {
  window.__STORE__ = globalStore
}

// ❌ Wrong: Not using proper store access
export function useStore() {
  // ❌ Wrong: Accessing window directly
  return process.client ? window.__STORE__ : globalStore
}

// ❌ Wrong: No TypeScript types
export function updateStore(key, value) {
  const store = useStore()
  store.state[key] = value
}

</example>


## Critical Rules
- ALWAYS use Pinia for state management
- Use proper TypeScript types
- Handle async operations properly
- Avoid direct state mutations
- Implement proper error handling
- Handle SSR properly
