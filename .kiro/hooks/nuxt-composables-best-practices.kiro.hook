{
  "enabled": true,
  "name": "Nuxt Composables Best Practices",
  "description": "Follow best practices for creating and using composables in Nuxt",
  "version": "1",
  "when": {
    "type": "fileEdited",
    "patterns": [
      "**/composables/**/*.ts",
      "**/composables/**/*.js"
    ]
  },
  "then": {
    "type": "askAgent",
    "prompt": "# Nuxt Composables Best Practices\n## Context\nRules for creating and using composables in Nuxt applications. Composables are auto-imported from the composables/ directory.\n## Requirements\n- Name composables with \"use\" prefix (e.g., useCounter)\n- Return reactive values using ref/reactive\n- Handle SSR compatibility in composables\n- Implement proper cleanup in onUnmounted when needed\n- Use TypeScript for better type inference\n- Document composable parameters and return values\n- Handle error states within composables\n- Use useState for shared state management\n- Implement proper disposal of resources\n- Consider using async composables with useAsyncData\n## Examples\n<example>\nexport async function useAsyncResource<T>(\n  key: string,\n  fetcher: () => Promise<T>,\n) {\n  // Use built-in composables\n  const nuxtApp = useNuxtApp()\n  // Use useAsyncData for data fetching\n  const { data, error, refresh } = await useAsyncData(\n    key,\n    () => fetcher(),\n    {\n      // Handle errors\n      onRequestError: ({ error }) => {\n        console.error(`Failed to fetch ${key}:`, error)\n      },\n      // Transform data if needed\n      transform: response => response,\n      // Cache management\n      watch: false,\n      // SSR options\n      server: true,\n      lazy: false,\n    },\n  )\n  // Provide refresh method\n  async function refetchData() {\n    await refresh()\n  }\n  return {\n    data: readonly(data),\n    error: readonly(error),\n    refresh: refetchData,\n  }\n}\n</example>\n<example>\nimport { useState } from '#app'\nexport interface UseCounterOptions {\n  initial?: number\n  min?: number\n  max?: number\n}\nexport function useCounter(options: UseCounterOptions = {}) {\n  const {\n    initial = 0,\n    min = Number.MIN_SAFE_INTEGER,\n    max = Number.MAX_SAFE_INTEGER,\n  } = options\n  // Use useState for SSR-friendly state\n  const count = useState('counter', () => initial)\n  function increment() {\n    if (count.value < max) {\n      count.value++\n    }\n  }\n  function decrement() {\n    if (count.value > min) {\n      count.value--\n    }\n  }\n  // Cleanup if needed\n  onUnmounted(() => {\n    // Clear state when component unmounts\n    count.value = initial\n  })\n  return {\n    count: readonly(count),\n    increment,\n    decrement,\n  }\n}\n</example>\n<example type=\"invalid\">\n// ❌ WRONG: Not using \"use\" prefix\nexport function counter() {\n  const count = ref(0)\n  return { count }\n}\n</example>\n<example type=\"invalid\">\n// ❌ WRONG: Direct DOM manipulation\nexport function useWindowSize() {\n  const width = ref(0)\n  const height = ref(0)\n  // Direct window access will fail in SSR\n  width.value = window.innerWidth\n  height.value = window.innerHeight\n  // No cleanup\n  window.addEventListener('resize', () => {\n    width.value = window.innerWidth\n    height.value = window.innerHeight\n  })\n  return { width, height }\n}\n</example>\n## Critical Rules\n- ALWAYS use \"use\" prefix for composable names\n- Use useState for SSR-compatible shared state\n- Implement proper cleanup in onUnmounted\n- Handle SSR compatibility (no direct window/document access)\n- Return readonly refs when state should be immutable\n- Document composable parameters and return types"
  }
}